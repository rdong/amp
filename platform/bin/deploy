#!/bin/bash

SUCCESS=0

# run checks (tests); will be set to 1 by -c option
CHECK=0

# This script uses other scripts expected to be in the same directory
# This gets absolute path to script (resolving symlinks)
readonly SP="$(cd "$(dirname "$0")"; pwd -P)"

# dirs
readonly PLATFORMDIR="$(dirname $SP)"
readonly BOOTSTRAPDIR="$PLATFORMDIR/bootstrap"
readonly TESTSDIR="$PLATFORMDIR/tests"

export PATH="$SP:$BOOTSTRAPDIR:$PATH"

# commands
readonly awscli="docker run --rm -v $HOME/.aws:/root/.aws:ro -v $BOOTSTRAPDIR:$BOOTSTRAPDIR:ro cgswong/aws:latest aws"

# IP range that should have access to the docker remote API
readonly rapi_cidr="$(curl -sf ifconfig.co/ip)/32"
readonly localdomainname="local.atomiq.io"

# returns the target of the deployment: local or a cloud provider
deployment_target() {
  local _target
  _target=$(echo $(basename $0) | cut -d- -f2)
  if [[ $? -ne 0 || "$_target" = "$(basename $0)" ]]; then
    _target="local"
  fi
  echo $_target
}

# create the cluster and echo the cluster id
cluster_create() {
  local _clusterid
  local _status
  local _target
  _target="$(deployment_target)"
  case "$_target" in
  local|aws)
    # async
    if [[ $# -eq 0 ]]; then
      bootstrap $BOOTSTRAP_OPTIONS -t "$_target" -f
    else
      bootstrap $BOOTSTRAP_OPTIONS -t "$_target" -fi $1
    fi ;;
  esac
}

# destroy the cluster
cluster_destroy() {
  local _target
  _target="$(deployment_target)"
  case $_target in
  local|aws)
    bootstrap -t $_target -di $1 ;;
  esac
}

# status of cluster, expects the cluster id as argument
# 0 means healthy
cluster_status() {
  local _clusterid=$1
  local _status
  local _target
  _target=$(deployment_target)
  case $_target in
  local|aws)
    bootstrap -t $_target -s $_clusterid >/dev/null 2>&1 ;;
  esac
}

# size of cluster, expects the cluster id as argument
cluster_nodecount() {
  local _clusterid=$1
  local _target
  local _count
  _target=$(deployment_target)
  case $_target in
  local|aws)
    _count=$(bootstrap -t $_target -l $_clusterid | wc -l)
    if [[ $_count -gt 0 ]]; then
      echo $_count
      return 0
    fi
    echo "node count failed" >&2
    bootstrap -t $_target -l $_clusterid >&2
    return 1
    ;;
  *)
    echo "unknown deployment target ($_target)" >&2
    return 1 ;;
  esac
}

# creates a amp-stacks volume by sending the stacks to the host in a build context
create_amp_stacks_volume() {
  local builddir=$(mktemp -d)
  local dockerfile=$builddir/Dockerfile
  local image=amp-stacks-builder:local
  cat > $dockerfile << EOF
FROM alpine:3.5
COPY stacks /stacks
VOLUME /stacks
CMD ["true"]
EOF
  cp -pr $SP/../stacks $builddir/stacks
  docker build -t $image $builddir >/dev/null
  rm -rf $builddir
  docker run --rm -v amp-stacks:/stacks $image
  docker image rm $image > /dev/null
}

# sets hosts for Docker remote API and for the Docker registry
# depending on the deployment target
set_deployment_variables(){
  case $(deployment_target) in
  local)
    dockerhost=m1
    registryhost=127.0.0.1
    create_amp_stacks_volume
    amps="docker run -t --rm --network=hostnet -e TAG=$TAG -e REGISTRATION=$REGISTRATION -v amp-stacks:/stacks docker --host=$dockerhost"
    stacks_path=/stacks
    domainname=$localdomainname
    ;;
  aws)
    local awscf="$awscli --profile ${PROFILE:-default} --region ${REGION:-us-west-2} cloudformation"
    local _clusterid
    local _publicip
    _clusterid="$CID"
    echo "$CID" | grep -q "/" && _clusterid="$(echo $CID | awk -F/ '{print $2}')"
    # todo: use a secured remote API
    dockerhost=$($awscf describe-stacks --stack-name $_clusterid --query 'Stacks[0].Outputs[?OutputKey==`PublicManagerHost`].OutputValue' --output text) || exit 1
    # if the DNS name point to several engines, we need a single one to avoid strange CLI issues (run = 2 calls, create + start)
    _publicip=$(docker -H "$dockerhost" node inspect self -f '{{.Spec.Labels.PublicIP}}')
    [[ -n "$_publicip" && "$_publicip" != "<no value>" ]] && dockerhost=$_publicip
    registryhost=$($awscf describe-stacks --stack-name $_clusterid --query 'Stacks[0].Outputs[?OutputKey==`MirrorRegistries`].OutputValue' --output text) || exit 1
    # if a single registry is defined on this cluster, we'll push images on it
    # else, we'll skip the image push
    echo "$registryhost" | grep -q " " && registryhost=""
    amps="docker -H $dockerhost"
    stacks_path=$SP/../stacks
    domainname=$DOMAIN
    # variable used in sub scripts
    export DOCKERHOST=$dockerhost
    ;;
  esac
  registryurl=$(echo $registryhost | cut -d, -f1)
  # if no scheme, add the default port
  if echo $registryurl | grep -qv "://" && [[ -n "$registryurl" ]]; then registryurl=$registryurl:5000; fi
  echo "Docker host = $dockerhost"
  echo "Docker registry = $registryurl"
}

checkexit() {
  [[ $1 -ne 0 ]] && printf "${@:2} (exit $1)\n" && exit $1
}

cleanup() {
  docker volume rm amp-stacks >/dev/null 2>&1
  [[ SUCCESS -ne 1 && ! -z $CID && $(deployment_target) = "local" ]] && echo "clean up" && bootstrap -d $CID
}

ok() {
  echo ok $1
}

pushimage() {
  echo "push image: $1/$2"
  docker tag $2 $1/$2
  checkexit $? "error tagging image"
  docker push $1/$2
  checkexit $? "error pushing image"
  ok
}

deploystack() {
  echo "deploy $1 => $2"
  $amps stack deploy -c $stacks_path/$1 $2
  checkexit $? "error deploying stack"
  ok
}

# can only use this once the swarm is ready
lookup() {
  [[ -z $amps ]] && echo "error to use lookup before swarm is created" && return 1
  echo $amps run --rm --network=ampnet appcelerator/alpine:3.5.2 nslookup $1 >&2
  $amps run --rm --network=ampnet appcelerator/alpine:3.5.2 nslookup $1
}

# can only use this once the swarm is ready
kurl() {
  [[ -z $amps ]] && echo "error to use kurl before swarm is created" && return 1
  $amps run --rm --network=ampnet appcelerator/alpine:3.5.2 curl -L -s -o /dev/null -w '%{http_code}\n' $1
}

# pushes certificates in a Docker secret, ready to use by services in stack files
# for local bootstrap, a self signed certificate is created
# for cloud bootstrap, a valid certificate should be provided
# it has to be in the stacks folder, to allow access to the Docker client
prepare_certificates() {
  if [[ $# -ne 1 ]]; then
    return 1
  fi
  local name=$1
  local certfile="$SP/../stacks/$name.pem"
  if [[ $(deployment_target) = "local" ]]; then
    mv $(mkcert) $certfile
  fi
  if [[ ! -f "$certfile" ]]; then
    # TODO use certbot
    echo "can't find certificate $certfile" >&2
    return 1
  fi
  # copy the certificate in the amp-stacks volume
  cid=$(docker run -d --rm -v amp-stacks:/stacks alpine:3.5 sleep 15)
  if [[ $? -ne 0 || -z "$cid" ]]; then return 1; fi
  docker cp $certfile $cid:/stacks/$name.pem
  docker kill $cid
  echo "checking if the certificate secret is already defined"
  $amps secret ls | grep -q "certificate_atomiq" && return 0
  echo "creating the certificate secret"
  $amps secret create "certificate_atomiq" "$stacks_path/$name.pem"
}

while getopts ":w:m:t:l:T:c:r:g:n:" opt; do
  case $opt in
  w|m|t|l) # just pass it to the bootstrap script
    BOOTSTRAP_OPTIONS="$BOOTSTRAP_OPTIONS -${opt} $OPTARG"
    ;;
  T) # tag for images to deploy
    export TAG=$OPTARG
    ;;
  r) # tag for images to deploy
    export REGISTRATION=$OPTARG
    ;;
  c)
    CHECK=1
    ;;
  n) # domain for cluster deployment
    BOOTSTRAP_OPTIONS="$BOOTSTRAP_OPTIONS -${opt} $OPTARG"
    DOMAIN=$OPTARG
    if [[ ! -f $SP/../stacks/${DOMAIN}.pem ]]; then
      echo "can't find ${DOMAIN}.pem, abort" >&2
      exit 1
    fi
    ;;
  g) # region for cluster deployment
    REGION=$OPTARG
    ;;
  esac
done
shift "$((OPTIND-1))"

CID=$1

trap cleanup EXIT

echo "$(deployment_target) deployment"
if [ -z $CID ]; then
  echo "bootstrapping cluster"
  CID=$(cluster_create)
  checkexit $? "bootstrap failed"
  [[ -n "$CID" ]]
  checkexit $? "no cluster id"
else
  cluster_status $CID || cluster_create $CID
  checkexit $? "bootstrap failed"
fi

set_deployment_variables

echo "wait for cluster"
clustercheck -t 150 -p $(deployment_target) $CID
checkexit $? "cluster timed out"
ok

typeset -i nodecount
nodecount=$(cluster_nodecount $CID) || exit 1
echo "cluster size is $nodecount"

echo "wait for swarm mode"
swarmcheck -t 300 -c $nodecount
checkexit $? "swarm mode timed out"
ok

if [[ -n "$registryhost" ]]; then
  echo "wait for registry"
  curlcheck "${registryurl}/v2/" 200 180
  checkexit $? "registry timed out"
  ok
fi

if [[ "$TAG" = "local" ]]; then
  echo "push images to cluster"
  for image in amplifier amplifier-gateway ampbeat agent; do
    pushimage ${registryurl} appcelerator/${image}:${TAG:-local}
  done
else
  echo "image push to cluster is ignored (tag=${TAG:-latest})"
fi

maxwait=580
echo "deploy amp monitoring stack to cluster - stage 1"
deploystack ampmon.1.stack.yml amp
echo "wait for all amp monitoring stage 1 stack service replicas to be running"
servicescheck $maxwait
checkexit $? "amp monitoring stage 1 service replica checks timed out"
ok

echo "deploy amp monitoring stack to cluster - stage 2"
deploystack ampmon.2.stack.yml amp
echo "wait for all amp monitoring stage 2 service replicas to be running ($maxwait sec)"
servicescheck $maxwait
checkexit $? "amp monitoring stage 2 service replica checks timed out"
ok

echo "deploy amp stack to cluster"
deploystack amp.stack.yml amp
echo "wait for all amp service replicas to be running ($maxwait sec)"
servicescheck $maxwait
checkexit $? "amp service replica checks timed out"
ok

prepare_certificates "$domainname"
if [[ $? -eq 0 ]]; then
  echo "deploy amp proxy stack to cluster"
  deploystack ampproxy.stack.yml amp
  echo "wait for all amp proxy service replicas to be running ($maxwait sec)"
  servicescheck $maxwait
  checkexit $? "amp proxy service replica checks timed out"
  ok
else
  echo "won't deploy the proxy stack, there's no certificate"
fi

# final sanity checks
# ===================

servicescheck 0
checkexit $? "final service replica smoke check failed"
ok

echo
$amps service ls
echo

# sanity service lookup and ping checks after starting monitoring stack
echo "test nats availability"
lookup nats >/dev/null
checkexit $? "service lookup check failed: nats"
ok "service lookup check succeeded: nats"
kurl nats:8222
checkexit $? "service ping check failed: nats"
ok "service ping check succeeded: nats"

echo "test elasticsearch availability"
lookup elasticsearch >/dev/null
checkexit $? "service lookup check failed: elasticsearch"
ok "service lookup check succeeded: elasticsearch"
kurl elasticsearch:9200
checkexit $? "service ping check failed: elasticsearch"
ok "service ping check succeeded: elasticsearch"

# checks
# ======
if [[ $CHECK -eq 1 ]]; then
  time testscheck $TESTSDIR
  rv=$?
  checkexit $rv "tests failed: $rv"
  ok "tests passed"
fi

printf "\nCluster status: healthy\n$CID"
SUCCESS=1

